# -*- coding: utf-8 -*-
"""Gaussian boson sampling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SPj_INvPkeCvRGtYxk-V3E15yfOp59Pv
"""

!pip install xanadu-cloud-client

!xcc config set REFRESH_TOKEN "eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIwYTdjOGE5Yi1lMzdkLTQ0MzItOTU2OC0xNzI3YzEwNmYyMzEifQ.eyJpYXQiOjE3MjAzODUyNTksImp0aSI6IjdlMWM5OWM2LTFjNTAtNGY2Ny1iOWEwLTcxNzc1NmUyMDlhZSIsImlzcyI6Imh0dHBzOi8vcGxhdGZvcm0ueGFuYWR1LmFpL2F1dGgvcmVhbG1zL3BsYXRmb3JtIiwiYXVkIjoiaHR0cHM6Ly9wbGF0Zm9ybS54YW5hZHUuYWkvYXV0aC9yZWFsbXMvcGxhdGZvcm0iLCJzdWIiOiI0M2Q5NGM3NC1hYWYwLTQwNjUtOGE3MS04YjljODYxNmY3OTIiLCJ0eXAiOiJPZmZsaW5lIiwiYXpwIjoicHVibGljIiwic2Vzc2lvbl9zdGF0ZSI6IjA5ZTE3YmNjLTk4MDktNDk1YS1iYWYwLTgwOWI1MDEwNzNhMyIsInNjb3BlIjoicHVibGljLXJvbGVzIHByb2ZpbGUgZW1haWwgb2ZmbGluZV9hY2Nlc3MiLCJzaWQiOiIwOWUxN2JjYy05ODA5LTQ5NWEtYmFmMC04MDliNTAxMDczYTMifQ.WaGp-7S2KcQkM_UFoPKYTboJ-6kxiHEWOnvMSncuiME"

!xcc ping

pip install strawberryfields --upgrade

import numpy as np
import strawberryfields as sf
from strawberryfields.ops import *
# set the random seed
np.random.seed(42)

import numpy as np
from numpy.linalg import multi_dot
from scipy.linalg import block_diag

# define the linear interferometer
Uphase = np.diag([np.exp(0.5233*1j),np.exp(0.785*1j),np.exp(1.0466*1j),np.exp(1.57*1j)])

BSargs = [
    (0.785, 1.57),  # Beamsplitter 1
    (0.785, 1.57),  # Beamsplitter 2
    (1.0609, 1.57), # Beamsplitter 3
    (0.6835, 0),    # Beamsplitter 4
    (0.6835, 0),    # Beamsplitter 5
    (1.0466, 1.57), # Beamsplitter 6
    (0.7604, 0.785), # Beamsplitter 7
    (0.7604, 0.785)  # Beamsplitter 8
]

t_r_amplitudes = [(np.cos(q), np.exp(p*1j)*np.sin(q)) for q,p in BSargs]

BSunitaries = [np.array([[t, -np.conj(r)], [r, t]]) for t,r in t_r_amplitudes]

UBS1 = block_diag(*BSunitaries[0:2])
UBS2 = block_diag([[1]], BSunitaries[2], [[1]])
UBS3 = block_diag(*BSunitaries[3:5])
UBS4 = block_diag([[1]], BSunitaries[5], [[1]])
UBS5 = block_diag(*BSunitaries[6:8])

U = multi_dot([UBS5, UBS4, UBS3, UBS2, UBS1, Uphase])
print(np.round(U, 4))

from strawberryfields.ops import Sgate, Interferometer

# ... your U matrix definition ...

# create the 4 mode Strawberry Fields program
gbs = sf.Program(4)

with gbs.context as q:
    # define squeezing parameters
    squeezing_parameters = [0.5, 1, 1.5, 2]

    # prepare the input squeezed states
    for i, r in enumerate(squeezing_parameters):
        S = Sgate(r)  # Use r for the squeezing value
        S | q[i]

    # linear interferometer
    Interferometer(U) | q

eng = sf.Engine(backend="gaussian")
results = eng.run(gbs)

# Increase the cutoff
results.cutoff = 15
# Fock states to measure at output
measure_states = [[0,0,0,0], [0,1,0,1], [2,1,3,2]]

# extract the probabilities of calculating several
# different Fock states at the output, and print them to the terminal
for i in measure_states:
    prob = results.state.fock_prob(i)
    print("|{}>: {}".format("".join(str(j) for j in i), prob))

# Theoretical calculation using Hafnian
# Calculate Hafnian with individual squeezing normalization for target state |0,1,0,1>
from thewalrus import hafnian as haf
target_state1=[0,1,0,1]
for r in squeezing_parameters:
 B_1 = (np.dot(U, U.T) * np.tanh(r))[:, [1, 3]][[1, 3]]
 hafnian_prob1 = np.abs(haf(B_1))**2
 hafnian_prob1 /= np.cosh(r)**4  # for each mode
sf_prob1 = results.state.fock_prob(target_state1)
print("Hafnian Probability (|0,1,0,1>):",hafnian_prob1)
print("Strawberry Fields Probability (|0,1,0,1>):",sf_prob1)

# Calculate Hafnian with individual squeezing normalization for target state |0,0,0,0>
# This corresponds to the hafnian of an empty matrix, which is simply 1
target_state2=[0,0,0,0]
hafnian_prob2=1
for r in squeezing_parameters:
 hafnian_prob2 /= np.cosh(r)**4  # for each mode
# Experimental result from Strawberry Fields
sf_prob2 = results.state.fock_prob(target_state2)

print(f"Hafnian Probability (|{target_state2}>): {hafnian_prob2}")
print(f"Strawberry Fields Probability (|{target_state2}>): {sf_prob2}")

# Calculate Hafnian with individual squeezing normalization for target state |2,1,3,2>
target_state3=[2,1,3,2]
for r in squeezing_parameters:
 B_1 = (np.dot(U, U.T) * np.tanh(r))
 hafnian_prob3 = np.abs(haf(B_1))**2
 hafnian_prob3 /= np.cosh(r)**4  # for each mode
sf_prob3 = results.state.fock_prob(target_state3)
print("Hafnian Probability (|2,1,3,2>):",hafnian_prob3)
print("Strawberry Fields Probability (|2,1,3,2>):",sf_prob3)